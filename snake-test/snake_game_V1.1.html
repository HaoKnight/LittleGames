<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>贪吃蛇游戏 by Knight</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap");

      body {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        margin: 0;
        background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
        font-family: "Press Start 2P", cursive; /* Retro font */
        color: white;
        overflow: hidden;
      }

      /* 横屏模式下的布局调整 */
      /* 当屏幕较宽时（如PC或横屏平板），改为左右布局，游戏区居中，控件在侧边 */
      @media (orientation: landscape) and (min-width: 768px) {
        body {
          flex-direction: row;
          justify-content: center;
          align-items: center;
          gap: 20px;
          position: relative;
        }

        h1 {
          position: absolute;
          top: 10px;
          left: 50%;
          transform: translateX(-50%);
          margin: 0;
        }

        .game-container {
          flex: 0 0 auto;
          margin-top: 50px;
        }

        .controls-hint {
          position: absolute;
          bottom: 10px;
          left: 50%;
          transform: translateX(-50%);
          margin: 0;
        }

        .touch-controls {
          margin-top: 0;
          position: relative;
          flex-shrink: 0;
        }
      }

      h1 {
        margin-top: 0;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        font-size: 24px;
        margin-bottom: 10px;
      }

      .game-container {
        position: relative;
        padding: 10px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 15px;
        box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(5px);
        max-width: 100%;
        box-sizing: border-box;
      }

      canvas {
        border-radius: 10px;
        background-color: #222;
        box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
        display: block;
        max-width: 100%;
        height: auto;
      }

      #score-board {
        display: flex;
        justify-content: space-between;
        width: 100%;
        margin-bottom: 10px;
        font-size: 16px;
      }

      #message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.95);
        color: #333;
        padding: 30px;
        border-radius: 15px;
        text-align: center;
        display: none;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        min-width: 200px;
        z-index: 10;
      }

      /* 开始提示浮层，与游戏结束样式一致，默认显示 */
      #startOverlay {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.95);
        color: #333333;
        padding: 30px;
        border-radius: 15px;
        text-align: center;
        display: flex;
        flex-direction: column;
        align-items: center;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        min-width: 200px;
        z-index: 10;
      }

      /* 仅调整“开始游戏”按钮字号，不影响其他按钮 */
      #startOverlay button {
        font-size: 15px;
      }

      #message h2 {
        margin-top: 0;
        color: #e74c3c;
        font-size: 24px;
      }

      button {
        padding: 15px 30px;
        font-size: 16px;
        cursor: pointer;
        background: linear-gradient(to bottom, #2ecc71, #27ae60);
        color: white;
        border: none;
        border-radius: 50px;
        margin-top: 20px;
        font-family: "Press Start 2P", cursive;
        box-shadow: 0 4px 0 #219150;
        transition: transform 0.1s, box-shadow 0.1s;
      }

      button:active {
        transform: translateY(4px);
        box-shadow: 0 0 0 #219150;
      }

      button:hover {
        filter: brightness(1.1);
      }

      .controls-hint {
        margin-top: 15px;
        font-size: 10px;
        opacity: 0.8;
        text-align: center;
      }

      /* 竖屏模式下，优化布局避免重叠 */
      /* 针对手机竖屏，调整元素顺序（order），确保游戏区和控制区合理分布 */
      @media (orientation: portrait) {
        body {
          position: relative;
          min-height: 100vh;
          padding-bottom: 20px;
          justify-content: flex-start; /* 从顶部开始排列 */
          padding-top: 10px;
        }

        h1 {
          order: -1;
          margin-bottom: 5px;
          font-size: 20px;
        }

        .game-container {
          order: 0;
          margin-bottom: 10px;
        }

        /* 方向按键：显示在提示文字上方 */
        .touch-controls {
          order: 1;
          margin-bottom: 15px; /* 与提示文字之间的间距 */
          margin-top: 10px;
        }

        /* 提示文字：显示在方向按键下方 */
        .controls-hint {
          order: 2;
          position: relative;
          margin-top: 0;
          margin-bottom: 20px;
          z-index: 5;
          background: rgba(0, 0, 0, 0.5);
          padding: 8px 15px;
          border-radius: 8px;
          backdrop-filter: blur(5px);
          font-size: 9px;
          width: fit-content;
          margin-left: auto;
          margin-right: auto;
        }

        /* 在小屏幕手机上进一步调整 */
        @media (max-height: 800px) {
          h1 {
            font-size: 18px;
            margin-bottom: 3px;
          }

          .game-container {
            margin-bottom: 8px;
          }

          .touch-controls {
            margin-bottom: 12px;
            margin-top: 8px;
          }

          .controls-hint {
            font-size: 8px;
            padding: 6px 12px;
            margin-top: 0;
            margin-bottom: 15px;
          }
        }

        /* 在更小的屏幕上进一步压缩 */
        @media (max-height: 700px) {
          .touch-controls {
            transform: scale(0.9); /* 稍微缩小方向按键 */
            margin-bottom: 10px;
            margin-top: 5px;
          }

          .controls-hint {
            font-size: 7px;
            padding: 5px 10px;
            margin-top: 0;
            margin-bottom: 15px;
          }
        }
      }

      .key {
        display: inline-block;
        padding: 5px 8px;
        border: 1px solid rgba(255, 255, 255, 0.5);
        border-radius: 4px;
        margin: 0 2px;
        background: rgba(255, 255, 255, 0.1);
      }

      /* Touch Controls */
      .touch-controls {
        margin-top: 20px;
        display: grid;
        grid-template-columns: repeat(3, 90px);
        grid-template-rows: repeat(2, 90px);
        gap: 15px;
        justify-content: center;
        align-items: center;
        padding: 10px;
      }

      .control-btn {
        width: 90px;
        height: 90px;
        background: linear-gradient(
          135deg,
          rgba(46, 204, 113, 0.8),
          rgba(39, 174, 96, 0.8)
        );
        border: 3px solid rgba(255, 255, 255, 0.5);
        border-radius: 20px;
        color: white;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        transition: all 0.2s ease;
        box-shadow: 0 6px 15px rgba(0, 0, 0, 0.3),
          inset 0 2px 5px rgba(255, 255, 255, 0.2);
        position: relative;
        overflow: hidden;
      }

      .control-btn::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.2),
          transparent
        );
        opacity: 0;
        transition: opacity 0.2s ease;
      }

      .control-btn:hover::before {
        opacity: 1;
      }

      .control-btn:active {
        background: linear-gradient(
          135deg,
          rgba(39, 174, 96, 0.9),
          rgba(46, 204, 113, 0.9)
        );
        transform: scale(0.92) translateY(2px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4),
          inset 0 2px 5px rgba(0, 0, 0, 0.2);
      }

      /* 为不同方向的按钮添加不同颜色 */
      .control-btn.up {
        background: linear-gradient(
          135deg,
          rgba(52, 152, 219, 0.8),
          rgba(41, 128, 185, 0.8)
        );
      }
      .control-btn.up:active {
        background: linear-gradient(
          135deg,
          rgba(41, 128, 185, 0.9),
          rgba(52, 152, 219, 0.9)
        );
      }

      .control-btn.down {
        background: linear-gradient(
          135deg,
          rgba(155, 89, 182, 0.8),
          rgba(142, 68, 173, 0.8)
        );
      }
      .control-btn.down:active {
        background: linear-gradient(
          135deg,
          rgba(142, 68, 173, 0.9),
          rgba(155, 89, 182, 0.9)
        );
      }

      .control-btn.left {
        background: linear-gradient(
          135deg,
          rgba(241, 196, 15, 0.8),
          rgba(243, 156, 18, 0.8)
        );
      }
      .control-btn.left:active {
        background: linear-gradient(
          135deg,
          rgba(243, 156, 18, 0.9),
          rgba(241, 196, 15, 0.9)
        );
      }

      .control-btn.right {
        background: linear-gradient(
          135deg,
          rgba(231, 76, 60, 0.8),
          rgba(192, 57, 43, 0.8)
        );
      }
      .control-btn.right:active {
        background: linear-gradient(
          135deg,
          rgba(192, 57, 43, 0.9),
          rgba(231, 76, 60, 0.9)
        );
      }

      /* 箭头图标样式 */
      .arrow-icon {
        font-size: 42px;
        text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5),
          0 0 10px rgba(255, 255, 255, 0.3);
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.3));
        transition: transform 0.2s ease;
        display: block;
        line-height: 1;
      }

      .control-btn:active .arrow-icon {
        transform: scale(0.9);
      }

      .control-btn.up {
        grid-column: 2;
        grid-row: 1;
      }
      .control-btn.left {
        grid-column: 1;
        grid-row: 2;
      }
      .control-btn.down {
        grid-column: 2;
        grid-row: 2;
      }
      .control-btn.right {
        grid-column: 3;
        grid-row: 2;
      }

      /* Hide controls on larger screens if desired, but user asked for them */
      /* @media (min-width: 768px) { .touch-controls { display: none; } } */
    </style>
  </head>
  <body>
    <h1>SNAKE GAME</h1>

    <div class="game-container">
      <div id="score-board">
        <span>SCORE: <span id="score">0</span></span>
        <span>BEST: <span id="highScore">0</span></span>
      </div>
      <canvas id="gameCanvas"></canvas>

      <div id="startOverlay">
        <h2>Are You Ready?</h2>
        <p>Click to start the game</p>
        <button onclick="START()">START</button>
      </div>

      <div id="message">
        <h2 id="msgText">GAME OVER</h2>
        <p>SCORE: <span id="finalScore">0</span></p>
        <button onclick="resetGame()">RETRY</button>
      </div>
    </div>

    <div class="controls-hint">
      Use <span class="key">W</span><span class="key">A</span
      ><span class="key">S</span><span class="key">D</span> or
      <span class="key">Arrows</span> to move
    </div>

    <div class="touch-controls">
      <div
        class="control-btn up"
        onpointerdown="handleInput('UP'); event.preventDefault()"
      >
        <span class="arrow-icon">▲</span>
      </div>
      <div
        class="control-btn left"
        onpointerdown="handleInput('LEFT'); event.preventDefault()"
      >
        <span class="arrow-icon">◀</span>
      </div>
      <div
        class="control-btn down"
        onpointerdown="handleInput('DOWN'); event.preventDefault()"
      >
        <span class="arrow-icon">▼</span>
      </div>
      <div
        class="control-btn right"
        onpointerdown="handleInput('RIGHT'); event.preventDefault()"
      >
        <span class="arrow-icon">▶</span>
      </div>
    </div>

    <script>
      // 画布与基础元素
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const scoreElement = document.getElementById("score");
      const highScoreElement = document.getElementById("highScore");
      const messageElement = document.getElementById("message");
      const finalScoreElement = document.getElementById("finalScore");
      const startOverlay = document.getElementById("startOverlay");

      // 网格尺寸及画布动态宽高
      const blockSize = 20;
      let width, height;

      // 按窗口尺寸动态调整画布（保持网格对齐）
      // 核心逻辑：计算可用宽高，确保是 blockSize 的整数倍，保证网格完整
      function resizeCanvas() {
        // 预留上下控件空间，得到可用区域
        let availableWidth = window.innerWidth - 30;
        let availableHeight = window.innerHeight - 300;

        // 限制最大与最小高度，避免过大或过小
        if (availableWidth > 600) availableWidth = 600;
        if (availableHeight > 500) availableHeight = 500;
        if (availableHeight < 200) availableHeight = 200;

        // 向下取整，保持与 blockSize 对齐
        const cols = Math.floor(availableWidth / blockSize);
        const rows = Math.floor(availableHeight / blockSize);

        canvas.width = cols * blockSize;
        canvas.height = rows * blockSize;

        width = canvas.width;
        height = canvas.height;
      }

      // 页面初始自适应
      resizeCanvas();

      // 窗口尺寸变化时重算画布并重开一局（防止失真）
      let resizeTimeout;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          resizeCanvas();
          // 仅在正在游戏时重置，避免未开始就自动开局
          if (gameInterval) {
            initGame();
          }
        }, 200);
      });

      // 核心状态
      let snake = [];
      let food = {};
      let direction = "RIGHT"; // 当前方向
      let nextDirection = "RIGHT"; // 输入缓存方向
      let score = 0;
      let highScore = localStorage.getItem("snakeHighScore") || 0;
      let gameInterval;
      let isGameOver = false;
      let gameSpeed = 100;

      // Colors
      // 颜色主题
      const COLORS = {
        background: "#222",
        grid: "#333",
        snakeHead: "#2ecc71",
        snakeBody: "#27ae60",
        food: "#e74c3c",
        text: "#fff",
      };

      highScoreElement.innerText = highScore;

      // 初始化/重开一局
      // 重置游戏状态，计算蛇的初始位置（屏幕中心），并启动游戏循环
      function initGame() {
        // 以网格中心对齐，避免 0.5 格导致无法碰撞
        const startX = Math.floor(width / (2 * blockSize)) * blockSize;
        const startY = Math.floor(height / (2 * blockSize)) * blockSize;

        snake = [
          { x: startX, y: startY },
          { x: startX - blockSize, y: startY },
          { x: startX - 2 * blockSize, y: startY },
        ];
        direction = "RIGHT";
        nextDirection = "RIGHT";
        score = 0;
        isGameOver = false;
        scoreElement.innerText = score;
        messageElement.style.display = "none";
        createFood();
        if (gameInterval) clearInterval(gameInterval);
        gameInterval = setInterval(gameLoop, gameSpeed);
      }

      // 随机生成食物，避免落在蛇身上
      // 如果生成的坐标与蛇身重叠，则递归调用重新生成
      function createFood() {
        food = {
          x: Math.floor(Math.random() * (width / blockSize)) * blockSize,
          y: Math.floor(Math.random() * (height / blockSize)) * blockSize,
        };
        // Ensure food doesn't spawn on snake
        for (let part of snake) {
          if (part.x === food.x && part.y === food.y) {
            createFood();
            return;
          }
        }
      }

      // 绘制网格背景
      function drawGrid() {
        ctx.strokeStyle = COLORS.grid;
        ctx.lineWidth = 0.5;
        for (let x = 0; x <= width; x += blockSize) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
        }
        for (let y = 0; y <= height; y += blockSize) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }
      }

      // 绘制圆角矩形（蛇身/蛇头）
      function drawRoundedRect(x, y, width, height, radius, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(
          x + width,
          y + height,
          x + width - radius,
          y + height
        );
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();
      }

      // 绘制圆形（眼睛/食物）
      function drawCircle(x, y, radius, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
      }

      // 主绘制函数
      // 每一帧清空画布，重新绘制背景、食物和蛇的所有部分
      function draw() {
        // Clear screen
        ctx.fillStyle = COLORS.background;
        ctx.fillRect(0, 0, width, height);

        drawGrid();

        // Draw Food (Apple style)
        const foodRadius = blockSize / 2 - 2;
        const foodX = food.x + blockSize / 2;
        const foodY = food.y + blockSize / 2;

        // Glow effect
        ctx.shadowBlur = 15;
        ctx.shadowColor = COLORS.food;
        drawCircle(foodX, foodY, foodRadius, COLORS.food);
        ctx.shadowBlur = 0; // Reset shadow

        // Draw Snake
        for (let i = 0; i < snake.length; i++) {
          const isHead = i === 0;
          const x = snake[i].x;
          const y = snake[i].y;

          // Body segments slightly smaller to see separation
          const padding = 1;
          const size = blockSize - padding * 2;

          ctx.shadowBlur = isHead ? 10 : 0;
          ctx.shadowColor = COLORS.snakeHead;

          drawRoundedRect(
            x + padding,
            y + padding,
            size,
            size,
            isHead ? 6 : 4,
            isHead ? COLORS.snakeHead : COLORS.snakeBody
          );

          ctx.shadowBlur = 0;

          // Eyes for head
          if (isHead) {
            ctx.fillStyle = "white";
            const eyeSize = 3;
            const eyeOffset = 5;

            let leftEyeX, leftEyeY, rightEyeX, rightEyeY;

            if (direction === "RIGHT") {
              leftEyeX = x + blockSize - eyeOffset;
              leftEyeY = y + eyeOffset;
              rightEyeX = x + blockSize - eyeOffset;
              rightEyeY = y + blockSize - eyeOffset;
            } else if (direction === "LEFT") {
              leftEyeX = x + eyeOffset;
              leftEyeY = y + eyeOffset;
              rightEyeX = x + eyeOffset;
              rightEyeY = y + blockSize - eyeOffset;
            } else if (direction === "UP") {
              leftEyeX = x + eyeOffset;
              leftEyeY = y + eyeOffset;
              rightEyeX = x + blockSize - eyeOffset;
              rightEyeY = y + eyeOffset;
            } else if (direction === "DOWN") {
              leftEyeX = x + eyeOffset;
              leftEyeY = y + blockSize - eyeOffset;
              rightEyeX = x + blockSize - eyeOffset;
              rightEyeY = y + blockSize - eyeOffset;
            }

            drawCircle(leftEyeX, leftEyeY, eyeSize, "white");
            drawCircle(rightEyeX, rightEyeY, eyeSize, "white");

            // Pupils
            ctx.fillStyle = "black";
            drawCircle(leftEyeX, leftEyeY, 1.5, "black");
            drawCircle(rightEyeX, rightEyeY, 1.5, "black");
          }
        }
      }

      // 更新蛇位置与碰撞处理
      // 核心游戏逻辑：移动蛇头，检测碰撞（墙壁/自身），处理吃食物逻辑
      function update() {
        if (isGameOver) return;

        direction = nextDirection;

        // 计算新蛇头的位置
        const head = { x: snake[0].x, y: snake[0].y };

        if (direction === "RIGHT") head.x += blockSize;
        else if (direction === "LEFT") head.x -= blockSize;
        else if (direction === "UP") head.y -= blockSize;
        else if (direction === "DOWN") head.y += blockSize;

        // 边界碰撞检测：超出画布范围则游戏结束
        if (head.x < 0 || head.x >= width || head.y < 0 || head.y >= height) {
          gameOver();
          return;
        }

        // 身体碰撞检测：蛇头碰到身体任意部位则游戏结束
        for (let part of snake) {
          if (head.x === part.x && head.y === part.y) {
            gameOver();
            return;
          }
        }

        // 将新蛇头加入数组头部
        snake.unshift(head);

        // 吃到食物逻辑
        if (head.x === food.x && head.y === food.y) {
          score++;
          scoreElement.innerText = score;
          // 更新最高分
          if (score > highScore) {
            highScore = score;
            localStorage.setItem("snakeHighScore", highScore);
            highScoreElement.innerText = highScore;
          }
          createFood();
          // 难度提升：每吃一个食物，速度略微加快
          if (gameSpeed > 50) gameSpeed -= 1;
          clearInterval(gameInterval);
          gameInterval = setInterval(gameLoop, gameSpeed);
        } else {
          // 未吃到食物，移除蛇尾，保持长度不变（移动效果）
          snake.pop();
        }
      }

      // 帧循环：更新 + 绘制
      function gameLoop() {
        update();
        draw();
      }

      // 结束逻辑
      function gameOver() {
        isGameOver = true;
        clearInterval(gameInterval);
        finalScoreElement.innerText = score;
        messageElement.style.display = "block";
      }

      // 点击按钮重开
      function resetGame() {
        gameSpeed = 100;
        initGame();
      }

      // 首次开始，或手动开始一局
      function START() {
        // 避免重复启动多重 interval
        if (gameInterval) clearInterval(gameInterval);
        gameSpeed = 100;
        isGameOver = false;
        startOverlay.style.display = "none";
        messageElement.style.display = "none";
        initGame();
      }

      // 方向输入（含防反向立即撞死）
      // 只有当新方向不与当前方向相反时才生效（例如当前向右，不能直接向左）
      function handleInput(newDir) {
        if (newDir === "UP" && direction !== "DOWN") nextDirection = "UP";
        else if (newDir === "DOWN" && direction !== "UP")
          nextDirection = "DOWN";
        else if (newDir === "LEFT" && direction !== "RIGHT")
          nextDirection = "LEFT";
        else if (newDir === "RIGHT" && direction !== "LEFT")
          nextDirection = "RIGHT";
      }

      // 键盘控制
      document.addEventListener("keydown", (event) => {
        const key = event.key;
        // Prevent scrolling when using arrow keys
        if (
          ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(key)
        ) {
          event.preventDefault();
        }

        if (key === "ArrowUp" || key === "w") handleInput("UP");
        else if (key === "ArrowDown" || key === "s") handleInput("DOWN");
        else if (key === "ArrowLeft" || key === "a") handleInput("LEFT");
        else if (key === "ArrowRight" || key === "d") handleInput("RIGHT");
        else if (key === " " && isGameOver) resetGame();
      });

      // 默认展示开始按钮，不自动开局
      startOverlay.style.display = "flex";
    </script>
  </body>
</html>
