<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>贪吃蛇游戏 by Knight</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap");

      body {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        margin: 0;
        background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
        font-family: "Press Start 2P", cursive; /* Retro font */
        color: white;
        overflow: hidden;
      }

      h1 {
        margin-top: 0;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        font-size: 24px;
        margin-bottom: 10px;
      }

      .game-container {
        position: relative;
        padding: 10px;
        background: rgba(0, 0, 0, 0.5);
        border-radius: 15px;
        box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(5px);
        max-width: 100%;
        box-sizing: border-box;
      }

      canvas {
        border-radius: 10px;
        background-color: #222;
        box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
        display: block;
        max-width: 100%;
        height: auto;
      }

      #score-board {
        display: flex;
        justify-content: space-between;
        width: 100%;
        margin-bottom: 10px;
        font-size: 16px;
      }

      #message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(255, 255, 255, 0.95);
        color: #333;
        padding: 30px;
        border-radius: 15px;
        text-align: center;
        display: none;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        min-width: 200px;
        z-index: 10;
      }

      #message h2 {
        margin-top: 0;
        color: #e74c3c;
        font-size: 24px;
      }

      button {
        padding: 15px 30px;
        font-size: 16px;
        cursor: pointer;
        background: linear-gradient(to bottom, #2ecc71, #27ae60);
        color: white;
        border: none;
        border-radius: 50px;
        margin-top: 20px;
        font-family: "Press Start 2P", cursive;
        box-shadow: 0 4px 0 #219150;
        transition: transform 0.1s, box-shadow 0.1s;
      }

      button:active {
        transform: translateY(4px);
        box-shadow: 0 0 0 #219150;
      }

      button:hover {
        filter: brightness(1.1);
      }

      .controls-hint {
        margin-top: 15px;
        font-size: 10px;
        opacity: 0.8;
        text-align: center;
      }

      .key {
        display: inline-block;
        padding: 5px 8px;
        border: 1px solid rgba(255, 255, 255, 0.5);
        border-radius: 4px;
        margin: 0 2px;
        background: rgba(255, 255, 255, 0.1);
      }

      /* Touch Controls */
      .touch-controls {
        margin-top: 20px;
        display: grid;
        grid-template-columns: repeat(3, 60px);
        grid-template-rows: repeat(2, 60px);
        gap: 10px;
        justify-content: center;
        align-items: center;
      }

      .control-btn {
        width: 60px;
        height: 60px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        color: white;
        font-size: 24px;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        transition: background 0.1s, transform 0.1s;
      }

      .control-btn:active {
        background: rgba(255, 255, 255, 0.3);
        transform: scale(0.95);
      }

      .control-btn.up {
        grid-column: 2;
        grid-row: 1;
      }
      .control-btn.left {
        grid-column: 1;
        grid-row: 2;
      }
      .control-btn.down {
        grid-column: 2;
        grid-row: 2;
      }
      .control-btn.right {
        grid-column: 3;
        grid-row: 2;
      }

      /* Hide controls on larger screens if desired, but user asked for them */
      /* @media (min-width: 768px) { .touch-controls { display: none; } } */
    </style>
  </head>
  <body>
    <h1>SNAKE GAME</h1>

    <div class="game-container">
      <div id="score-board">
        <span>SCORE: <span id="score">0</span></span>
        <span>BEST: <span id="highScore">0</span></span>
      </div>
      <canvas id="gameCanvas"></canvas>

      <div id="message">
        <h2 id="msgText">GAME OVER</h2>
        <p>SCORE: <span id="finalScore">0</span></p>
        <button onclick="resetGame()">RETRY</button>
      </div>
    </div>

    <div class="controls-hint">
      Use <span class="key">W</span><span class="key">A</span
      ><span class="key">S</span><span class="key">D</span> or
      <span class="key">Arrows</span> to move
    </div>

    <div class="touch-controls">
      <div
        class="control-btn up"
        onpointerdown="handleInput('UP'); event.preventDefault()"
      >
        ▲
      </div>
      <div
        class="control-btn left"
        onpointerdown="handleInput('LEFT'); event.preventDefault()"
      >
        ◀
      </div>
      <div
        class="control-btn down"
        onpointerdown="handleInput('DOWN'); event.preventDefault()"
      >
        ▼
      </div>
      <div
        class="control-btn right"
        onpointerdown="handleInput('RIGHT'); event.preventDefault()"
      >
        ▶
      </div>
    </div>

    <script>
      // 画布与基础元素
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const scoreElement = document.getElementById("score");
      const highScoreElement = document.getElementById("highScore");
      const messageElement = document.getElementById("message");
      const finalScoreElement = document.getElementById("finalScore");

      // 网格尺寸及画布动态宽高
      const blockSize = 20;
      let width, height;

      // 按窗口尺寸动态调整画布（保持网格对齐）
      function resizeCanvas() {
        // 预留上下控件空间，得到可用区域
        let availableWidth = window.innerWidth - 30;
        let availableHeight = window.innerHeight - 300;

        // 限制最大与最小高度，避免过大或过小
        if (availableWidth > 600) availableWidth = 600;
        if (availableHeight > 500) availableHeight = 500;
        if (availableHeight < 200) availableHeight = 200;

        // 向下取整，保持与 blockSize 对齐
        const cols = Math.floor(availableWidth / blockSize);
        const rows = Math.floor(availableHeight / blockSize);

        canvas.width = cols * blockSize;
        canvas.height = rows * blockSize;

        width = canvas.width;
        height = canvas.height;
      }

      // 页面初始自适应
      resizeCanvas();

      // 窗口尺寸变化时重算画布并重开一局（防止失真）
      let resizeTimeout;
      window.addEventListener("resize", () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          resizeCanvas();
          initGame();
        }, 200);
      });

      // 核心状态
      let snake = [];
      let food = {};
      let direction = "RIGHT"; // 当前方向
      let nextDirection = "RIGHT"; // 输入缓存方向
      let score = 0;
      let highScore = localStorage.getItem("snakeHighScore") || 0;
      let gameInterval;
      let isGameOver = false;
      let gameSpeed = 100;

      // Colors
      // 颜色主题
      const COLORS = {
        background: "#222",
        grid: "#333",
        snakeHead: "#2ecc71",
        snakeBody: "#27ae60",
        food: "#e74c3c",
        text: "#fff",
      };

      highScoreElement.innerText = highScore;

      // 初始化/重开一局
      function initGame() {
        // 以网格中心对齐，避免 0.5 格导致无法碰撞
        const startX =
          Math.floor(width / (2 * blockSize)) * blockSize;
        const startY =
          Math.floor(height / (2 * blockSize)) * blockSize;

        snake = [
          { x: startX, y: startY },
          { x: startX - blockSize, y: startY },
          { x: startX - 2 * blockSize, y: startY },
        ];
        direction = "RIGHT";
        nextDirection = "RIGHT";
        score = 0;
        isGameOver = false;
        scoreElement.innerText = score;
        messageElement.style.display = "none";
        createFood();
        if (gameInterval) clearInterval(gameInterval);
        gameInterval = setInterval(gameLoop, gameSpeed);
      }

      // 随机生成食物，避免落在蛇身上
      function createFood() {
        food = {
          x: Math.floor(Math.random() * (width / blockSize)) * blockSize,
          y: Math.floor(Math.random() * (height / blockSize)) * blockSize,
        };
        // Ensure food doesn't spawn on snake
        for (let part of snake) {
          if (part.x === food.x && part.y === food.y) {
            createFood();
            return;
          }
        }
      }

      // 绘制网格背景
      function drawGrid() {
        ctx.strokeStyle = COLORS.grid;
        ctx.lineWidth = 0.5;
        for (let x = 0; x <= width; x += blockSize) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
        }
        for (let y = 0; y <= height; y += blockSize) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }
      }

      // 绘制圆角矩形（蛇身/蛇头）
      function drawRoundedRect(x, y, width, height, radius, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(
          x + width,
          y + height,
          x + width - radius,
          y + height
        );
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
        ctx.fill();
      }

      // 绘制圆形（眼睛/食物）
      function drawCircle(x, y, radius, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
      }

      // 主绘制函数
      function draw() {
        // Clear screen
        ctx.fillStyle = COLORS.background;
        ctx.fillRect(0, 0, width, height);

        drawGrid();

        // Draw Food (Apple style)
        const foodRadius = blockSize / 2 - 2;
        const foodX = food.x + blockSize / 2;
        const foodY = food.y + blockSize / 2;

        // Glow effect
        ctx.shadowBlur = 15;
        ctx.shadowColor = COLORS.food;
        drawCircle(foodX, foodY, foodRadius, COLORS.food);
        ctx.shadowBlur = 0; // Reset shadow

        // Draw Snake
        for (let i = 0; i < snake.length; i++) {
          const isHead = i === 0;
          const x = snake[i].x;
          const y = snake[i].y;

          // Body segments slightly smaller to see separation
          const padding = 1;
          const size = blockSize - padding * 2;

          ctx.shadowBlur = isHead ? 10 : 0;
          ctx.shadowColor = COLORS.snakeHead;

          drawRoundedRect(
            x + padding,
            y + padding,
            size,
            size,
            isHead ? 6 : 4,
            isHead ? COLORS.snakeHead : COLORS.snakeBody
          );

          ctx.shadowBlur = 0;

          // Eyes for head
          if (isHead) {
            ctx.fillStyle = "white";
            const eyeSize = 3;
            const eyeOffset = 5;

            let leftEyeX, leftEyeY, rightEyeX, rightEyeY;

            if (direction === "RIGHT") {
              leftEyeX = x + blockSize - eyeOffset;
              leftEyeY = y + eyeOffset;
              rightEyeX = x + blockSize - eyeOffset;
              rightEyeY = y + blockSize - eyeOffset;
            } else if (direction === "LEFT") {
              leftEyeX = x + eyeOffset;
              leftEyeY = y + eyeOffset;
              rightEyeX = x + eyeOffset;
              rightEyeY = y + blockSize - eyeOffset;
            } else if (direction === "UP") {
              leftEyeX = x + eyeOffset;
              leftEyeY = y + eyeOffset;
              rightEyeX = x + blockSize - eyeOffset;
              rightEyeY = y + eyeOffset;
            } else if (direction === "DOWN") {
              leftEyeX = x + eyeOffset;
              leftEyeY = y + blockSize - eyeOffset;
              rightEyeX = x + blockSize - eyeOffset;
              rightEyeY = y + blockSize - eyeOffset;
            }

            drawCircle(leftEyeX, leftEyeY, eyeSize, "white");
            drawCircle(rightEyeX, rightEyeY, eyeSize, "white");

            // Pupils
            ctx.fillStyle = "black";
            drawCircle(leftEyeX, leftEyeY, 1.5, "black");
            drawCircle(rightEyeX, rightEyeY, 1.5, "black");
          }
        }
      }

      // 更新蛇位置与碰撞处理
      function update() {
        if (isGameOver) return;

        direction = nextDirection;

        const head = { x: snake[0].x, y: snake[0].y };

        if (direction === "RIGHT") head.x += blockSize;
        else if (direction === "LEFT") head.x -= blockSize;
        else if (direction === "UP") head.y -= blockSize;
        else if (direction === "DOWN") head.y += blockSize;

        // 边界碰撞
        if (head.x < 0 || head.x >= width || head.y < 0 || head.y >= height) {
          gameOver();
          return;
        }

        // 身体碰撞
        for (let part of snake) {
          if (head.x === part.x && head.y === part.y) {
            gameOver();
            return;
          }
        }

        snake.unshift(head);

        // 吃到食物
        if (head.x === food.x && head.y === food.y) {
          score++;
          scoreElement.innerText = score;
          if (score > highScore) {
            highScore = score;
            localStorage.setItem("snakeHighScore", highScore);
            highScoreElement.innerText = highScore;
          }
          createFood();
          // Increase speed slightly
          if (gameSpeed > 50) gameSpeed -= 1;
          clearInterval(gameInterval);
          gameInterval = setInterval(gameLoop, gameSpeed);
        } else {
          snake.pop();
        }
      }

      // 帧循环：更新 + 绘制
      function gameLoop() {
        update();
        draw();
      }

      // 结束逻辑
      function gameOver() {
        isGameOver = true;
        clearInterval(gameInterval);
        finalScoreElement.innerText = score;
        messageElement.style.display = "block";
      }

      // 点击按钮重开
      function resetGame() {
        gameSpeed = 100;
        initGame();
      }

      // 方向输入（含防反向立即撞死）
      function handleInput(newDir) {
        if (newDir === "UP" && direction !== "DOWN") nextDirection = "UP";
        else if (newDir === "DOWN" && direction !== "UP")
          nextDirection = "DOWN";
        else if (newDir === "LEFT" && direction !== "RIGHT")
          nextDirection = "LEFT";
        else if (newDir === "RIGHT" && direction !== "LEFT")
          nextDirection = "RIGHT";
      }

      // 键盘控制
      document.addEventListener("keydown", (event) => {
        const key = event.key;
        // Prevent scrolling when using arrow keys
        if (
          ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " "].includes(key)
        ) {
          event.preventDefault();
        }

        if (key === "ArrowUp" || key === "w") handleInput("UP");
        else if (key === "ArrowDown" || key === "s") handleInput("DOWN");
        else if (key === "ArrowLeft" || key === "a") handleInput("LEFT");
        else if (key === "ArrowRight" || key === "d") handleInput("RIGHT");
        else if (key === " " && isGameOver) resetGame();
      });

      // 启动游戏
      initGame();
    </script>
  </body>
</html>
